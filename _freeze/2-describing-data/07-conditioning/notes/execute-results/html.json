{
  "hash": "e075903910bd120a320a400efebe1ab5",
  "result": {
    "markdown": "---\ntitle: \"Conditioning\"\nsubtitle: \"Filtering, groupwise operations, and data pipelines.\"\ndate: \"09/14/2022\"\nimage: images/penguin-plot.png\nformat:\n  html:\n    code-fold: true\n    code-link: true\n    code-summary: \".\"\nexecute: \n  warning: false\n  message: false\nfrom: markdown+emoji\n---\n\n\n[[Discuss](https://app.perusall.com)]{.btn .btn-primary} [[Reading Questions](https://www.gradescope.com/courses/416233)]{.btn .btn-primary} [[PDF](notes.pdf)]{.btn .btn-primary}\n\n\\\n\n[I]{.dropcap}n the world of data, bigger is not always better. Sometimes there are real benefits to working with a subset of your observations that meet some particular condition. One use of conditioning is to add specificity to a claim. Another use of conditioning is to illuminate the relationship between variables.\n\nTo practice with conditioning, let's turn to a data set that begins with a very general focus. In 2007, Savage and West published *A qualitative, theoretical framework for understanding mammalian sleep*[^msleep], wherein they \"develop a general, quantitative theory for mammalian sleep that relates many of its fundamental parameters to metabolic rate and body size\". Characterizing the sleep patterns of *all* mammals is a broad task and their data set is corresponding diverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nmsleep <- msleep %>%\n    mutate(log_bodywt = log(bodywt * 1000)) %>%\n    select(name, sleep_total, log_bodywt, \n           vore, conservation)\n\nmsleep\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 83 × 5\n   name                       sleep_total log_bodywt vore  conservation\n   <chr>                            <dbl>      <dbl> <chr> <chr>       \n 1 Cheetah                           12.1      10.8  carni lc          \n 2 Owl monkey                        17         6.17 omni  <NA>        \n 3 Mountain beaver                   14.4       7.21 herbi nt          \n 4 Greater short-tailed shrew        14.9       2.94 omni  lc          \n 5 Cow                                4        13.3  herbi domesticated\n 6 Three-toed sloth                  14.4       8.26 herbi <NA>        \n 7 Northern fur seal                  8.7       9.93 carni vu          \n 8 Vesper mouse                       7         3.81 <NA>  <NA>        \n 9 Dog                               10.1       9.55 carni domesticated\n10 Roe deer                           3         9.60 herbi lc          \n# … with 73 more rows\n```\n:::\n:::\n\n\nIn this data set, the unit of observation is a single species and the variables observed on each are its name, the average length of sleep each day, the natural log of the average weight, its dietary pattern, and its conservation status. We can visualize the relationship between sleep and body size in all 83 species using a scatter plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_labels <- filter(msleep, \n                    name %in% c(\"Little brown bat\",\n                                \"African elephant\"))\n\nlibrary(ggrepel)\np_sleep <- msleep %>%\n    ggplot(aes(x = log_bodywt,\n                   y = sleep_total)) +\n    geom_point() +\n    geom_text_repel(data = df_labels, \n                    aes(label = name), \n                    min.segment.length = 0,\n                    box.padding = 2.5) +\n    labs(x = \"body weight (in log grams)\",\n         y = \"total sleep per day (in hrs)\") +\n    theme_bw()\n\np_sleep\n```\n\n::: {.cell-output-display}\n![](notes_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nThe mammals vary from the wee brown bat, slumbering for nearly 20 hours a day, to the massive African elephant, nodding off for less than five. That is quite a range! Lets drill down to smaller subsets of this data frame to gain a more nuanced sense of what is going on.\n\n[^msleep]: V. M. Savage and G. B. West. [A quantitative, theoretical framework for understanding mammalian sleep](https://www.pnas.org/doi/10.1073/pnas.0610080104). Proceedings of the National Academy of Sciences, 104 (3):1051-1056, 2007.\n\n## Filtering\n\nIf you think about the shape of a data frame, there are two basic ways you might go about slicing and dicing it into smaller subsets.\n\nOne way is to go at it column-by-column. The act of selecting a subset of the columns of a data frame is called, well, *selecting*. When you select a column, you can do so either by its name or by its column number (or index). Selecting columns by name is more useful because their order tends to be arbitrary and might change over the course of an analysis.\n\nThe other way to go at it is row-by-row. The act of subsetting the rows of the data frame based on their row number is called *slicing*. As with columns, the order of the rows is also often arbitrary, so this is of limited use. Much more useful is *filtering*.\n\n:::{.column-margin}\nIn the tidyverse, these functions are named `select()`, `slice()`, and `filter()`.\n:::\n\n**Filtering**\n\n:   The act of subsetting the rows of a data frame based on the values of one or more variables to extract the observations of interest.\n\nFilters are powerful because they are they comb through the values of the data frame, which is where most of the information is. The key part of any filter is the condition that you assert for the rows that are retained in your data frame. Let's set up a filter to return only the little brown bat.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfilter(msleep, name == \"Little brown bat\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 5\n  name             sleep_total log_bodywt vore    conservation\n  <chr>                  <dbl>      <dbl> <chr>   <chr>       \n1 Little brown bat        19.9       2.30 insecti <NA>        \n```\n:::\n:::\n\n\nHere `name == \"Little brown bat\"` is the condition that must be met by any row in the data set that is returned. The syntax used to set up the condition is a comparison between a column in the data frame on the left and a possible value of that column on the right.\n\n### Comparison Operators\n\nThe filter above uses the most direct condition: it retains the rows that have a value in the `name` variable that is precisely `\"Little brown bat\"`. In this case, there is only one such row. There are a range of different comparisons that can be made, though, and each has its own operator.\n\n:::: {.columns}\n\n::: {.column width=\"20%\"}\n:::\n\n::: {.column width=\"60%\"}\n| Operator | Translation               |\n|----------|--------------------------|\n| `==`     | equal to                 |\n| `!=`     | not equal to             |\n| `<`      | less than                |\n| `>`      | greater than             |\n| `<=`     | less than or equal to    |\n| `>=`     | greater than or equal to |\n:::\n\n::: {.column width=\"20%\"}\n:::\n\n::::\n\nAt first, the `==` operator looks like a typo. Why doesn't we use `=`? The reason is that a single equals sign is already busy at work in R: it sets the values of arguments inside a function. Here, it is determinining whether the thing on the left holds the same value as the thing on the right. It might help you keep things straight if you read it in your head as \"is exactly equal to\".\n\nLet's return only the rows with large animals, defined as those with a log body weight greater than 6.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfilter(msleep, log_bodywt > 12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 5\n  name                 sleep_total log_bodywt vore  conservation\n  <chr>                      <dbl>      <dbl> <chr> <chr>       \n1 Cow                          4         13.3 herbi domesticated\n2 Asian elephant               3.9       14.8 herbi en          \n3 Horse                        2.9       13.2 herbi domesticated\n4 Donkey                       3.1       12.1 herbi domesticated\n5 Giraffe                      1.9       13.7 herbi cd          \n6 Pilot whale                  2.7       13.6 carni cd          \n7 African elephant             3.3       15.7 herbi vu          \n8 Brazilian tapir              4.4       12.2 herbi vu          \n9 Bottle-nosed dolphin         5.2       12.1 carni <NA>        \n```\n:::\n:::\n\n\nThere were 9 such animals and all of them large.\n\n### Logical Operators\n\nWhat if you want both the little brown bat and the African elephant? What if you want both the large creatures as well as those that sleep only briefly? These are tasks that call for multiple comparisons composed together with the logical operators `&`, `|`, and `%in%`.\n\nThis filter returns the creates who are large and who sleep little.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfilter(msleep, log_bodywt > 12 & sleep_total < 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 5\n  name             sleep_total log_bodywt vore  conservation\n  <chr>                  <dbl>      <dbl> <chr> <chr>       \n1 Cow                      4         13.3 herbi domesticated\n2 Asian elephant           3.9       14.8 herbi en          \n3 Horse                    2.9       13.2 herbi domesticated\n4 Donkey                   3.1       12.1 herbi domesticated\n5 Giraffe                  1.9       13.7 herbi cd          \n6 Pilot whale              2.7       13.6 carni cd          \n7 African elephant         3.3       15.7 herbi vu          \n8 Brazilian tapir          4.4       12.2 herbi vu          \n```\n:::\n:::\n\n\nThis can be read as \"filter the msleep data frmae to return the rows where both the log body weight is greater than 12 and the sleep total is less than 5\". We see that there are 8 such creatures, one fewer than the data frame with only the body weight filter (bottle-nosed dolphins sleep, on average, 5.2 hrs).\n\nUsing `&` to represent \"and\" is common across most computer languages but you can alternatively use the somewhat more compact syntax of simply adding the second filter after a comma.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfilter(msleep, log_bodywt > 12, sleep_total < 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 5\n  name             sleep_total log_bodywt vore  conservation\n  <chr>                  <dbl>      <dbl> <chr> <chr>       \n1 Cow                      4         13.3 herbi domesticated\n2 Asian elephant           3.9       14.8 herbi en          \n3 Horse                    2.9       13.2 herbi domesticated\n4 Donkey                   3.1       12.1 herbi domesticated\n5 Giraffe                  1.9       13.7 herbi cd          \n6 Pilot whale              2.7       13.6 carni cd          \n7 African elephant         3.3       15.7 herbi vu          \n8 Brazilian tapir          4.4       12.2 herbi vu          \n```\n:::\n:::\n\n\nThese two methods are equivalent.\n\nTo return all rows that either have a high body weight or low sleep time or both, use the `|` operator (sometimes called \"vertical bar\").\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfilter(msleep, log_bodywt > 12 | sleep_total < 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 5\n   name                 sleep_total log_bodywt vore  conservation\n   <chr>                      <dbl>      <dbl> <chr> <chr>       \n 1 Cow                          4        13.3  herbi domesticated\n 2 Roe deer                     3         9.60 herbi lc          \n 3 Asian elephant               3.9      14.8  herbi en          \n 4 Horse                        2.9      13.2  herbi domesticated\n 5 Donkey                       3.1      12.1  herbi domesticated\n 6 Giraffe                      1.9      13.7  herbi cd          \n 7 Pilot whale                  2.7      13.6  carni cd          \n 8 African elephant             3.3      15.7  herbi vu          \n 9 Sheep                        3.8      10.9  herbi domesticated\n10 Caspian seal                 3.5      11.4  carni vu          \n11 Brazilian tapir              4.4      12.2  herbi vu          \n12 Bottle-nosed dolphin         5.2      12.1  carni <NA>        \n```\n:::\n:::\n\n\nBe cautious in deciding whether you want to use `&`  or `|`. While `|` is generally read as \"or\", we could also describe the above filter as one that returns the rows that have a high body weight and the rows that have low sleep times.\n\nOne way to keep them straight is to keep an eye on the number of observations that are returned. The intersection of multiple conditions (using `&`) should result in the same or fewer rows (the orange area) than the union of multiple conditions (using `|`) (the blue area). \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(patchwork)\n\np_and <- p_sleep +\n    annotate(\"rect\", xmin = 12, xmax = 16,\n             ymin = 1.5, ymax = 5, \n             fill = \"orange\", alpha = .4)\n\np_or <- p_sleep +\n    annotate(\"rect\", xmin = 12, xmax = 16,\n             ymin = 1.5, ymax = 20, \n             fill = \"blue\", alpha = .4) +\n    annotate(\"rect\", xmin = 2, xmax = 12,\n             ymin = 1.5, ymax = 5, \n             fill = \"blue\", alpha = .4)\n\np_and + p_or\n```\n\n::: {.cell-output-display}\n![](notes_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nWhen working with nominal categorical variables, the only operator that you'll be using is `==`. You can return a union like normal using `|`,\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfilter(msleep, name == \"Little brown bat\" | name == \"African elephant\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  name             sleep_total log_bodywt vore    conservation\n  <chr>                  <dbl>      <dbl> <chr>   <chr>       \n1 African elephant         3.3      15.7  herbi   vu          \n2 Little brown bat        19.9       2.30 insecti <NA>        \n```\n:::\n:::\n\n\nOr you can save some typing (and craft more readable code) by using `%in%` instead:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfilter(msleep, name %in% c(\"Little brown bat\", \"African elephant\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  name             sleep_total log_bodywt vore    conservation\n  <chr>                  <dbl>      <dbl> <chr>   <chr>       \n1 African elephant         3.3      15.7  herbi   vu          \n2 Little brown bat        19.9       2.30 insecti <NA>        \n```\n:::\n:::\n\n\n\n### Taxonomy of Data: Logicals\n\nIt is useful to pause here to look under the hood of this code. Once you get accustomed to the comparison operators and the syntax, the R code reads very similarly to the equivalent english command. But how are those comparisons being represented in terms of data?\n\nTo answer this question, consider a simple numeric vector of four integers.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\na <- c(2, 4, 6, 8)\n```\n:::\n\n\nWe can apply a comparison operator to this vector using the same syntax as above. Let's compare each value in this vector to see if its less than 5.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\na < 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\nThe result is a vector of the same length as `a` where each value indicates whether the comparison to each element was true or false. While it looks like a factor or a character vector `TRUE` and `FALSE`, this is actually our newest entry into the Taxonomy of Data: the **logical vector**.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nclass(a < 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\nA logical vector can only take two values, `TRUE` and `FALSE` (R also recognizes `T` and `F` but not `True` or `true`). While it might seem like a categorical variable with only two levels, a logical vector has an important property that makes it behave like a numerical variable.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nsum(a < 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nIn a logical vector, a value of true is represented both by `TRUE` and by the number 1 and false by `FALSE` and the number 0. This integer representation is why `TRUE + TRUE` will work (it's 2!) but `\"TRUE\" + \"TRUE\"` will not.\n\nThis dual representation is very useful because it allows us to compute a proportion using, paradoxically, the `mean()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmean(a < 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n:::\n\n\n`a < 5` results in a vector with two 1s and two 0. When you take the mean like this, you're really finding the proportion of the elements that meet the condition that you laid out in your comparison. This is a very handy trick. We'll use it more in a moment.\n\n<!-- ## Missing Data -->\n\n<!-- ```{r} -->\n<!-- #| code-fold: false -->\n\n<!-- filter(msleep, log_bodywt > 6) -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- #| code-fold: false -->\n\n<!-- filter(msleep, !is.na(log_bodywt), -->\n<!--        log_bodywt > 6) -->\n<!-- ``` -->\n\n## Data Pipelines\n\nAt this stage in the course, the number of functions that you are familiar with has grown dramatically. To do truly powerful things with data, you need to not just call one of these functions, but string together many of them in a thoughtful and organized manner.\n\nAn an example, to create a sorted data frame containing just the large animals, we need to take the original data frame and\n\n1. `filter()` such that `log_bodywt > 12` and then\n2. `arrange()` in descending order of weight (`desc(log_bodywt)`).\n\nA conventional approach breaks this process into two distinct lines of code and saves the output mid-way through.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmsleep_large <- filter(msleep, log_bodywt > 12)\narrange(msleep_large, desc(log_bodywt))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 5\n  name                 sleep_total log_bodywt vore  conservation\n  <chr>                      <dbl>      <dbl> <chr> <chr>       \n1 African elephant             3.3       15.7 herbi vu          \n2 Asian elephant               3.9       14.8 herbi en          \n3 Giraffe                      1.9       13.7 herbi cd          \n4 Pilot whale                  2.7       13.6 carni cd          \n5 Cow                          4         13.3 herbi domesticated\n6 Horse                        2.9       13.2 herbi domesticated\n7 Brazilian tapir              4.4       12.2 herbi vu          \n8 Donkey                       3.1       12.1 herbi domesticated\n9 Bottle-nosed dolphin         5.2       12.1 carni <NA>        \n```\n:::\n:::\n\n\nAn approach that is more concise, easier to read, and generally faster to run is to compose these functions together with \"the pipe\". The pipe, written `%>%`, is an operator that you have access to when you load the tidyverse package. If you have two functions, `f1` and `f2`, both of which take a data frame as the first argument, you can pipe the output of `f1` directly into `f2` using.\n\n:::{style=\"font-size: 1.5em; text-align: center\"}\n```\nf1(DF) %>% f2()\n```\n:::\n\nLet's use the pipe to rewrite the code shown above.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nfilter(msleep, log_bodywt > 12) %>% arrange(desc(log_bodywt))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 5\n  name                 sleep_total log_bodywt vore  conservation\n  <chr>                      <dbl>      <dbl> <chr> <chr>       \n1 African elephant             3.3       15.7 herbi vu          \n2 Asian elephant               3.9       14.8 herbi en          \n3 Giraffe                      1.9       13.7 herbi cd          \n4 Pilot whale                  2.7       13.6 carni cd          \n5 Cow                          4         13.3 herbi domesticated\n6 Horse                        2.9       13.2 herbi domesticated\n7 Brazilian tapir              4.4       12.2 herbi vu          \n8 Donkey                       3.1       12.1 herbi domesticated\n9 Bottle-nosed dolphin         5.2       12.1 carni <NA>        \n```\n:::\n:::\n\n\nWhat has changed? Most immediately, we have reduced two lines of code to one. The first function, `filter()`, is unchanged however the second function, `arrange()`, is now missing its first argument, the data frame. That is because it is being piped directly in from the output of the first function.\n\nWhile this is a fine way to use the pipe, your code is made much more readable if you format it like this:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmsleep %>%\n    filter(log_bodywt > 12) %>% \n    arrange(desc(log_bodywt))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 5\n  name                 sleep_total log_bodywt vore  conservation\n  <chr>                      <dbl>      <dbl> <chr> <chr>       \n1 African elephant             3.3       15.7 herbi vu          \n2 Asian elephant               3.9       14.8 herbi en          \n3 Giraffe                      1.9       13.7 herbi cd          \n4 Pilot whale                  2.7       13.6 carni cd          \n5 Cow                          4         13.3 herbi domesticated\n6 Horse                        2.9       13.2 herbi domesticated\n7 Brazilian tapir              4.4       12.2 herbi vu          \n8 Donkey                       3.1       12.1 herbi domesticated\n9 Bottle-nosed dolphin         5.2       12.1 carni <NA>        \n```\n:::\n:::\n\n\nThis code results in same output as the first version, but it now reads a bit like a poem: \"Take the msleep data frame then filter it such that the log body weight is greater than twelve then arrange it in descending order by log body weight\".\n\n:::{.column-margin}\nThis poem is admittedly not particularly poetic.\n:::\n\nLet's look at a few examples to understand the power of such a simple piece of syntax.\n\n### Examples\n\n*What year had the greatest total number of christenings?*\n\nIn Lab 1, this question was tacked with two or three separate lines of code, one to `mutate()` and the other to `arrange()` (and possibly `select()`). As one pipeline, it is:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(stat20data)\ndata(arbuthnot)\n\narbuthnot %>%\n    mutate(total = boys + girls) %>%\n    arrange(desc(total)) %>%\n    select(year, total)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 82 × 2\n    year total\n   <int> <int>\n 1  1705 16145\n 2  1707 16066\n 3  1698 16052\n 4  1708 15862\n 5  1697 15829\n 6  1702 15687\n 7  1701 15616\n 8  1703 15448\n 9  1706 15369\n10  1699 15363\n# … with 72 more rows\n```\n:::\n:::\n\n\n*What is the trend in the total number of christenings over time?*\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\narbuthnot %>%\n    mutate(total = boys + girls) %>%\n    ggplot(aes(x = year, y = total)) +\n    geom_line()\n```\n\n::: {.cell-output-display}\n![](notes_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nThis demonstrates that you can pipe a data frame directly into a ggplot - the first argument is a data frame after all! The main thing to note is that when moving into a ggplot, the layers are added with the `+` operator instead of the pipe, `%>%`.\n\n*What proportion of carnivores sleep more than 8 hours per night?*\n\nAnswering this requires two steps: `filter()`ing to focus on carnivores and `summarize()`ing with a proportion that meet a condition (recall that a comparison results in a logical vector of 0s and 1s). It is often a good idea to record the number of observations that go into a summary statistic, which we do here with `n()`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmsleep %>%\n    filter(vore == \"carni\") %>%\n    summarize(p_gt_8hrs = mean(sleep_total > 8),\n              n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  p_gt_8hrs     n\n      <dbl> <int>\n1     0.684    19\n```\n:::\n:::\n\n\n## Groupwise Operations\n\nThe last example above demonstrates a very common scenario: you want to performa some calculations on one particular group of observations in your data set. But what if you want to do that same calculation for every group?\n\nThe `vore` variable has four levels: `carni`, `herbi`, `insecti`, and `omni`. It would not be too difficult to copy and paste the above pipeline four times and modify each filter function to focus on a different group. But what if there were a dozen different levels?\n\nThis task - performing an operation on all groups of a data set one-by-one - is such a common data science task that nearly every software tool has a good solution. In the tidyverse, the solution is the `group_by()` function. Let's see it in action.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmsleep %>%\n    group_by(vore) %>%\n    summarize(p_gt_8hrs = mean(sleep_total > 8),\n              n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  vore    p_gt_8hrs     n\n  <chr>       <dbl> <int>\n1 carni       0.684    19\n2 herbi       0.594    32\n3 insecti     1         5\n4 omni        0.95     20\n5 <NA>        0.714     7\n```\n:::\n:::\n\n\nLike most tidyverse functions, the first argument to `group_by()` is a data frame, so it can be slotted directly into the pipeline. The second argument, the one that shows up in the code above, is the name of the variable that you want to use to delineate the groups. This is generally a factor, character, or logical vector.\n\n`group_by()` is an incredibly powerful function because it changes the behavior of downstream functions. Lets break our pipeline and inspect the data frame that comes out of it.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmsleep %>%\n    group_by(vore)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 83 × 5\n# Groups:   vore [5]\n   name                       sleep_total log_bodywt vore  conservation\n   <chr>                            <dbl>      <dbl> <chr> <chr>       \n 1 Cheetah                           12.1      10.8  carni lc          \n 2 Owl monkey                        17         6.17 omni  <NA>        \n 3 Mountain beaver                   14.4       7.21 herbi nt          \n 4 Greater short-tailed shrew        14.9       2.94 omni  lc          \n 5 Cow                                4        13.3  herbi domesticated\n 6 Three-toed sloth                  14.4       8.26 herbi <NA>        \n 7 Northern fur seal                  8.7       9.93 carni vu          \n 8 Vesper mouse                       7         3.81 <NA>  <NA>        \n 9 Dog                               10.1       9.55 carni domesticated\n10 Roe deer                           3         9.60 herbi lc          \n# … with 73 more rows\n```\n:::\n:::\n\n\nThis look . . . exactly like the original data frame.\n\nWell, not *exactly* like it: there is now a note at the top that the data frame now has the notion of groups based on `vore`. In effect, `group_by()` has taken the generic data frame and turned it into the one in the middle below: the same data frame but with rows now flagged as belonging to one group or another. When we pipe this grouped data frame into `summarize()`, which collapses that data frame down into a single row for each group and creates a new column for each new summary statistic.\n\n![](images/group-by.png){fig-align=center width=\"500px\"}\n\n[^dplyrcheat]: From the dplyr cheat sheet: <https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf>.\n\n## Summary\n\nThere are several ways to subset a data frame but the most important for data analysis is filtering: subsetting the rows according to a condition. In R, that condition is framed in terms of a comparison between a vector and a value (or set of values). Comparisons and take many forms and can be combined using logical operators. The result is a logical vector that can be used for filtering or computing summary statistics. You can perform simulataneous analyses on multiple subsets by doing groupwise operations with `group_by()`.\n\nAs we begin to do analyses that require multiple operations, the pipe operator, `%>%`, can be used to stitch the functions together into a single pipeline.\n\nIf you're thinking, :grimacing: , yikes there was a *lot* of coding in these notes, you're right. Don't worry. We'll have plenty of time to practice in class and there is no lab due next week.\n\n<!-- ## Faceted Plots -->\n\n<!-- {{< include ../../assets/_links-to-materials.qmd >}} -->\n",
    "supporting": [
      "notes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}