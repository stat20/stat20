{
  "hash": "81697365d4bd9f59caa0e5f21ad0745e",
  "result": {
    "markdown": "---\ntitle: \"Method of Least Squares\"\nformat:\n  revealjs:\n    author: \"STAT 20: Introduction to Probability and Statistics\"\n    height: 900\n    width: 1600\n    theme: ../../assets/slides.scss\n    multiplex: false\n    transition: fade\n    slide-number: c\n    incremental: false\n    center: false\n    menu: false\n    highlight-style: github\n    progress: false\n    code-overflow: wrap\n    title-slide-attributes:\n      data-background-image: ../../assets/stat20-hex-bg.png\n      data-background-size: contain\nexecute: \n  echo: false\n---\n\n\n## Agenda\n\n- Linear Models Review\n- Concept Questions\n- Optimization with Algorithms\n- Problem Set 6.1: Method of Least Squares\n\n\n# Linear Models Review\n\nGo to `pollev.com` and get ready for a kahoot.\n\n\n## Concept Questions\n\n##\n\nScenario 1, asking them to identify the a. response variable, b. predictor variables, and c. whether it requires a regression or a classification model.\n\n# Fitting Predictive Models via Optimization\n\n## Two approaches\n\n::::{.columns}\n:::{.column width=\"50%\"}\n#### Calculus\n\nCertain models (like least squares) can be fit simply by taking partial derivatives, setting to 0, and solving.\n:::\n\n:::{.column width=\"50%\" .fragment}\n#### Algorithms\n\nThere are many iterative algorithms that accomplish the same task, some better than others. Two examples:\n\n- Gradient Descent: the most-used algorithm currently. Used to fit deep learning models.\n- Nelder-Mead: an older and more general (and generally not as reliable!) algorithm.\n:::\n::::\n\n## Nelder-Mead\n\n::::{.columns}\n:::{.column width=\"70%\"}\n\n> The downhill simplex method now takes a series of steps, most steps just moving the point of the simplex where the function is largest (“highest point”) through the opposite face of the simplex to a lower point. These steps are called reflections, and they are constructed to conserve the volume of the simplex (and hence maintain its nondegeneracy). When it can do so, the method expands the simplex in one or another direction to take larger steps. When it reaches a “valley floor”, the method contracts itself in the transverse direction and tries to ooze down the valley. If there is a situation where the simplex is trying to “pass through the eye of a needle”, it contracts itself in all directions, pulling itself in around its lowest (best) point. (from Wikipedia)\n:::\n\n:::{.column width=\"30%\"}\n![](images/Nelder-Mead_Himmelblau.gif)\n:::\n::::\n\n## Nelder-Mead on a simple function\n\nCan we use Nelder-Mead to find the mimimum value of this function (with zero calculus)?\n\n$$\nf(x) = \\left(x + .5 \\right)^2\n$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/unnamed-chunk-1-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## Writing a new function in R {auto-animate=\"true\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1\"}\nf <- function(x) {\n  (x + .5)^2\n}\n```\n:::\n\n\n1. Functions are created with `function()` and assigned to an object (here, our new function is `f()`)\n2. The arguments go inside the parens of `function()`\n\n## Writing a new function in R {auto-animate=\"true\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2\"}\nf <- function(x) {\n  (x + .5)^2\n}\n```\n:::\n\n\n1. Functions are created with `function()` and assigned to an object (here, our new function is `f()`)\n2. The arguments go inside the parens of `function()`\n3. The guts of the function goes between `{}`.\n4. Once you run this function once, you'll have access to `f()` in your environment.\n\n## Finding values of $f(x)$ {auto-animate=\"true\"}\n\n::::{.columns}\n:::{.column width=\"50%\"}\n$$\nf(x) = \\left(x + .5 \\right)^2\n$$\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  (x + .5)^2\n}\n```\n:::\n\n\n:::\n::::\n\n## Finding values of $f(x)$ {auto-animate=\"true\"}\n\n::::{.columns}\n:::{.column width=\"50%\"}\n$$\nf(x) = \\left(x + .5 \\right)^2\n$$\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  (x + .5)^2\n}\n\nf(x = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.25\n```\n:::\n:::\n\n\n:::\n::::\n\n\n## Finding values of $f(x)$ {auto-animate=\"true\"}\n\n::::{.columns}\n:::{.column width=\"50%\"}\n$$\nf(x) = \\left(x + .5 \\right)^2\n$$\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  (x + .5)^2\n}\n```\n:::\n\n\n:::\n::::\n\n## Finding values of $f(x)$ {auto-animate=\"true\"}\n\n::::{.columns}\n:::{.column width=\"50%\"}\n$$\nf(x) = \\left(x + .5 \\right)^2\n$$\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  (x + .5)^2\n}\n\nf(x = .75)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.5625\n```\n:::\n:::\n\n\n:::\n::::\n\n## Finding minimum value of $f(x)$ {auto-animate=\"true\"}\n\n::::{.columns}\n:::{.column width=\"50%\"}\n$$\nf(x) = \\left(x + .5 \\right)^2\n$$\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n:::\n\n:::\n\n:::{.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  (x + .5)^2\n}\n\noptim(par = .5, fn = f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$par\n[1] -0.4\n\n$value\n[1] 0.01\n\n$counts\nfunction gradient \n      12       NA \n\n$convergence\n[1] 0\n\n$message\nNULL\n```\n:::\n:::\n\n\n:::\n::::\n\n## Notes on `optim()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptim(par = .5, fn = f)\n```\n:::\n\n\n- The function to optimize is passed to `fn`. You provide a starting point for the algorithm with `par` (which must be a scalar or a vector).\n- This is a random algorithm - each time you run it you'll get a (slightly) different answer.\n- The best guess of the algorithm will be returned as `$par`\n\n. . .\n\n**optim's guess**: 0.4\n\n**true answer**: 0.5\n\n\n# Problem Set\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"countdown\" id=\"timer_b71d1806\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">25</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n:::\n:::\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/countdown-0.4.0/countdown.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/countdown-0.4.0/countdown.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}